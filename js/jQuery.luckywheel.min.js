function Luckywheel(t, e) {
  defaultOptions = {
    canvasId: "canvas",
    centerX: null,
    centerY: null,
    outerRadius: null,
    innerRadius: 0,
    numSegments: 1,
    rotationAngle: 0,
    textFontFamily: "Verdana",
    textFontSize: 20,
    textFontWeight: "bold",
    textOrientation: "horizontal",
    textAlignment: "center",
    textDirection: "normal",
    textMargin: null,
    wheelTextColor: "#ffffff",
    textStrokeStyle: null,
    textLineWidth: 1,
    fillStyle: "gold",
    WheelStrokeColor: "blue",
    WheelStrokeWidth: "3",
    clearTheCanvas: !0,
    drawText: !0,
    pointerAngle: 0,
  };
  for (var i in defaultOptions)
    null != t && void 0 !== t[i]
      ? (this[i] = t[i])
      : (this[i] = defaultOptions[i]);
  if (null != t) for (var i in t) void 0 === this[i] && (this[i] = t[i]);
  for (
    this.canvasId
      ? ((this.canvas = document.getElementById(this.canvasId)),
        this.canvas
          ? (null == this.centerX && (this.centerX = this.canvas.width / 2),
            null == this.centerY && (this.centerY = this.canvas.height / 2),
            null == this.outerRadius &&
              (this.canvas.width < this.canvas.height
                ? (this.outerRadius =
                    this.canvas.width / 2 - this.WheelStrokeWidth)
                : (this.outerRadius =
                    this.canvas.height / 2 - this.WheelStrokeWidth)),
            (this.ctx = this.canvas.getContext("2d")))
          : ((this.canvas = null), (this.ctx = null)))
      : ((this.cavnas = null), (this.ctx = null)),
      this.segments = new Array(null),
      x = 1;
    x <= this.numSegments;
    x++
  )
    null != t && t.segments && void 0 !== t.segments[x - 1]
      ? (this.segments[x] = new Segment(t.segments[x - 1]))
      : (this.segments[x] = new Segment());
  this.updateSegmentSizes(),
    null === this.textMargin && (this.textMargin = this.textFontSize / 1.7),
    null != t && t.animation && void 0 !== t.animation
      ? (this.animation = new Animation(t.animation))
      : (this.animation = new Animation()),
    void 0 === e && (e = !0),
    null != t && t.pointerGuide && void 0 !== t.pointerGuide
      ? (this.pointerGuide = new PointerGuide(t.pointerGuide))
      : (this.pointerGuide = new PointerGuide()),
    1 == e && this.draw(this.clearTheCanvas);
}
function Animation(t) {
  defaultOptions = {
    type: "spinOngoing",
    direction: "clockwise",
    propertyName: null,
    propertyValue: null,
    duration: 10,
    yoyo: !1,
    repeat: null,
    easing: null,
    stopAngle: null,
    spins: null,
    clearTheCanvas: null,
    callbackFinished: null,
    callbackBefore: null,
    callbackAfter: null,
    callbackSound: null,
    soundTrigger: "segment",
  };
  for (var e in defaultOptions)
    null != t && void 0 !== t[e]
      ? (this[e] = t[e])
      : (this[e] = defaultOptions[e]);
  if (null != t) for (var e in t) void 0 === this[e] && (this[e] = t[e]);
}
function Segment(t) {
  defaultOptions = {
    size: null,
    text: "",
    fillStyle: null,
    WheelStrokeColor: null,
    WheelStrokeWidth: null,
    textFontFamily: null,
    textFontSize: null,
    textFontWeight: null,
    textOrientation: null,
    textAlignment: null,
    textDirection: null,
    textMargin: null,
    wheelTextColor: null,
    textStrokeStyle: null,
    textLineWidth: null,
    image: true,
    imageDirection: null,
    imgData: null,
  };
  for (var e in defaultOptions)
    null != t && void 0 !== t[e]
      ? (this[e] = t[e])
      : (this[e] = defaultOptions[e]);
  if (null != t) for (var e in t) void 0 === this[e] && (this[e] = t[e]);
  (this.startAngle = 0), (this.endAngle = 0);
}
function PointerGuide(t) {
  defaultOptions = {
    display: !1,
    WheelStrokeColor: "red",
    WheelStrokeWidth: 3,
  };
  for (var e in defaultOptions)
    null != t && void 0 !== t[e]
      ? (this[e] = t[e])
      : (this[e] = defaultOptions[e]);
}
function luckywheelAnimationLoop() {
  if (luckywheelToDrawDuringAnimation) {
    0 != luckywheelToDrawDuringAnimation.animation.clearTheCanvas &&
      luckywheelToDrawDuringAnimation.ctx.clearRect(
        0,
        0,
        luckywheelToDrawDuringAnimation.canvas.width,
        luckywheelToDrawDuringAnimation.canvas.height
      );
    var callbackBefore =
        luckywheelToDrawDuringAnimation.animation.callbackBefore,
      callbackAfter = luckywheelToDrawDuringAnimation.animation.callbackAfter;
    null != callbackBefore &&
      ("function" == typeof callbackBefore
        ? callbackBefore()
        : eval(callbackBefore)),
      luckywheelToDrawDuringAnimation.draw(!1),
      null != callbackAfter &&
        ("function" == typeof callbackAfter
          ? callbackAfter()
          : eval(callbackAfter)),
      luckywheelToDrawDuringAnimation.animation.callbackSound &&
        winwheelTriggerSound();
  }
}
(Luckywheel.prototype.updateSegmentSizes = function () {
  if (this.segments) {
    var t = 0,
      e = 0;
    for (x = 1; x <= this.numSegments; x++)
      null !== this.segments[x].size && ((t += this.segments[x].size), e++);
    var i = 360 - t,
      n = 0;
    i > 0 && (n = i / (this.numSegments - e));
    var s = 0;
    for (x = 1; x <= this.numSegments; x++)
      (this.segments[x].startAngle = s),
        this.segments[x].size ? (s += this.segments[x].size) : (s += n),
        (this.segments[x].endAngle = s);
  }
}),
  (Luckywheel.prototype.clearCanvas = function () {
    this.ctx && this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }),
  (Luckywheel.prototype.draw = function (t) {
    this.numSegments=4
    this.ctx &&
      (void 0 !== t ? 1 == t && this.clearCanvas() : this.clearCanvas(),
      this.drawSegments(),
      1 == this.drawText && this.drawSegmentText());
  }),
  (Luckywheel.prototype.drawSegments = function () {
    if (this.ctx && this.segments)
    //
      for (x = 1; x <= this.numSegments; x++) {
        var t, e, i;
        (seg = this.segments[x]),
          (t = null !== seg.fillStyle ? seg.fillStyle : this.fillStyle),
          (this.ctx.fillStyle = t),
          (e =
            null !== seg.WheelStrokeWidth
              ? seg.WheelStrokeWidth
              : this.WheelStrokeWidth),
          (this.ctx.lineWidth = e),
          (i =
            null !== seg.WheelStrokeColor
              ? seg.WheelStrokeColor
              : this.WheelStrokeColor),
          (this.ctx.strokeStyle = i),
          (i || t) &&
            (this.ctx.beginPath(),
            this.innerRadius || this.ctx.moveTo(this.centerX, this.centerY),
            this.ctx.arc(
              this.centerX,
              this.centerY,
              this.outerRadius,
              this.degreeToRadious(seg.startAngle + this.rotationAngle - 90),
              this.degreeToRadious(seg.endAngle + this.rotationAngle - 90),
              !1
            ),
            this.innerRadius
              ? this.ctx.arc(
                  this.centerX,
                  this.centerY,
                  this.innerRadius,
                  this.degreeToRadious(seg.endAngle + this.rotationAngle - 90),
                  this.degreeToRadious(
                    seg.startAngle + this.rotationAngle - 90
                  ),
                  !0
                )
              : this.ctx.lineTo(this.centerX, this.centerY),
            t && this.ctx.fill(),
            i && this.ctx.stroke());
      }
  }),
  (Luckywheel.prototype.drawSegmentText = function () {
    var t, e, n, s, a, r, l, o, h, c, u;
    if (this.ctx)
      for (x = 1; x <= this.numSegments; x++) {
        if ((this.ctx.save(), (seg = this.segments[x]), seg.text)) {
          (t =
            null !== seg.textFontFamily
              ? seg.textFontFamily
              : this.textFontFamily),
            (e =
              null !== seg.textFontSize ? seg.textFontSize : this.textFontSize),
            (n =
              null !== seg.textFontWeight
                ? seg.textFontWeight
                : this.textFontWeight),
            (s =
              null !== seg.textOrientation
                ? seg.textOrientation
                : this.textOrientation),
            (a =
              null !== seg.textAlignment
                ? seg.textAlignment
                : this.textAlignment),
            (r =
              null !== seg.textDirection
                ? seg.textDirection
                : this.textDirection),
            (l = null !== seg.textMargin ? seg.textMargin : this.textMargin),
            (o =
              null !== seg.wheelTextColor
                ? seg.wheelTextColor
                : this.wheelTextColor),
            (h =
              null !== seg.textStrokeStyle
                ? seg.textStrokeStyle
                : this.textStrokeStyle),
            (c =
              null !== seg.textLineWidth
                ? seg.textLineWidth
                : this.textLineWidth),
            (u = ""),
            null != n && (u += n + " "),
            null != e && (u += e + "px "),
            null != t && (u += t),
            (this.ctx.font = u),
            (this.ctx.fillStyle = o),
            (this.ctx.strokeStyle = h),
            (this.ctx.lineWidth = c);
          var g = seg.text.split("\n"),
            d = 0 - e * (g.length / 2) + e / 2;
          for (
            "curved" != s || ("inner" != a && "outer" != a) || (d = 0), i = 0;
            i < g.length;
            i++
          ) {
            if ("reversed" == r) {
              if ("horizontal" == s) {
                (this.ctx.textAlign =
                  "inner" == a ? "right" : "outer" == a ? "left" : "center"),
                  (this.ctx.textBaseline = "middle");
                var m = this.degreeToRadious(
                  seg.endAngle -
                    (seg.endAngle - seg.startAngle) / 2 +
                    this.rotationAngle -
                    90 -
                    180
                );
                this.ctx.save(),
                  this.ctx.translate(this.centerX, this.centerY),
                  this.ctx.rotate(m),
                  this.ctx.translate(-this.centerX, -this.centerY),
                  "inner" == a
                    ? (o &&
                        this.ctx.fillText(
                          g[i],
                          this.centerX - this.innerRadius - l,
                          this.centerY + d
                        ),
                      h &&
                        this.ctx.strokeText(
                          g[i],
                          this.centerX - this.innerRadius - l,
                          this.centerY + d
                        ))
                    : "outer" == a
                    ? (o &&
                        this.ctx.fillText(
                          g[i],
                          this.centerX - this.outerRadius + l,
                          this.centerY + d
                        ),
                      h &&
                        this.ctx.strokeText(
                          g[i],
                          this.centerX - this.outerRadius + l,
                          this.centerY + d
                        ))
                    : (o &&
                        this.ctx.fillText(
                          g[i],
                          this.centerX -
                            this.innerRadius -
                            (this.outerRadius - this.innerRadius) / 2 -
                            l,
                          this.centerY + d
                        ),
                      h &&
                        this.ctx.strokeText(
                          g[i],
                          this.centerX -
                            this.innerRadius -
                            (this.outerRadius - this.innerRadius) / 2 -
                            l,
                          this.centerY + d
                        )),
                  this.ctx.restore();
              } else if ("vertical" == s) {
                (this.ctx.textAlign = "center"),
                  (this.ctx.textBaseline =
                    "inner" == a ? "top" : "outer" == a ? "bottom" : "middle");
                m = seg.endAngle - (seg.endAngle - seg.startAngle) / 2 - 180;
                if (
                  ((m += this.rotationAngle),
                  this.ctx.save(),
                  this.ctx.translate(this.centerX, this.centerY),
                  this.ctx.rotate(this.degreeToRadious(m)),
                  this.ctx.translate(-this.centerX, -this.centerY),
                  "outer" == a)
                )
                  var p = this.centerY + this.outerRadius - l;
                else if ("inner" == a) p = this.centerY + this.innerRadius + l;
                var f = e - e / 9;
                if ("outer" == a)
                  for (var A = g[i].length - 1; A >= 0; A--)
                    (character = g[i].charAt(A)),
                      o && this.ctx.fillText(character, this.centerX + d, p),
                      h && this.ctx.strokeText(character, this.centerX + d, p),
                      (p -= f);
                else if ("inner" == a)
                  for (A = 0; A < g[i].length; A++)
                    (character = g[i].charAt(A)),
                      o && this.ctx.fillText(character, this.centerX + d, p),
                      h && this.ctx.strokeText(character, this.centerX + d, p),
                      (p += f);
                else if ("center" == a) {
                  var y = 0;
                  g[i].length > 1 && (y = (f * (g[i].length - 1)) / 2);
                  for (
                    p =
                      this.centerY +
                      this.innerRadius +
                      (this.outerRadius - this.innerRadius) / 2 +
                      y +
                      l,
                      A = g[i].length - 1;
                    A >= 0;
                    A--
                  )
                    (character = g[i].charAt(A)),
                      o && this.ctx.fillText(character, this.centerX + d, p),
                      h && this.ctx.strokeText(character, this.centerX + d, p),
                      (p -= f);
                }
                this.ctx.restore();
              } else if ("curved" == s) {
                var k = 0;
                "inner" == a
                  ? ((k = this.innerRadius + l),
                    (this.ctx.textBaseline = "top"))
                  : "outer" == a
                  ? ((k = this.outerRadius - l),
                    (this.ctx.textBaseline = "bottom"),
                    (k -= e * (g.length - 1)))
                  : "center" == a &&
                    ((k =
                      this.innerRadius +
                      l +
                      (this.outerRadius - this.innerRadius) / 2),
                    (this.ctx.textBaseline = "middle"));
                var w = 0,
                  T = 0;
                for (
                  g[i].length > 1
                    ? ((this.ctx.textAlign = "left"),
                      (w = (e / 10) * 4),
                      (radiusPercent = 100 / k),
                      (w *= radiusPercent),
                      (totalArc = w * g[i].length),
                      (T =
                        seg.startAngle +
                        ((seg.endAngle - seg.startAngle) / 2 - totalArc / 2)))
                    : ((T =
                        seg.startAngle + (seg.endAngle - seg.startAngle) / 2),
                      (this.ctx.textAlign = "center")),
                    T += this.rotationAngle,
                    T -= 180,
                    A = g[i].length;
                  A >= 0;
                  A--
                )
                  this.ctx.save(),
                    (character = g[i].charAt(A)),
                    this.ctx.translate(this.centerX, this.centerY),
                    this.ctx.rotate(this.degreeToRadious(T)),
                    this.ctx.translate(-this.centerX, -this.centerY),
                    h &&
                      this.ctx.strokeText(
                        character,
                        this.centerX,
                        this.centerY + k + d
                      ),
                    o &&
                      this.ctx.fillText(
                        character,
                        this.centerX,
                        this.centerY + k + d
                      ),
                    (T += w),
                    this.ctx.restore();
              }
            } else if ("horizontal" == s) {
              (this.ctx.textAlign =
                "inner" == a ? "left" : "outer" == a ? "right" : "center"),
                (this.ctx.textBaseline = "middle");
              m = this.degreeToRadious(
                seg.endAngle -
                  (seg.endAngle - seg.startAngle) / 2 +
                  this.rotationAngle -
                  90
              );
              this.ctx.save(),
                this.ctx.translate(this.centerX, this.centerY),
                this.ctx.rotate(m),
                this.ctx.translate(-this.centerX, -this.centerY),
                "inner" == a
                  ? (o &&
                      this.ctx.fillText(
                        g[i],
                        this.centerX + this.innerRadius + l,
                        this.centerY + d
                      ),
                    h &&
                      this.ctx.strokeText(
                        g[i],
                        this.centerX + this.innerRadius + l,
                        this.centerY + d
                      ))
                  : "outer" == a
                  ? (o &&
                      this.ctx.fillText(
                        g[i],
                        this.centerX + this.outerRadius - l,
                        this.centerY + d
                      ),
                    h &&
                      this.ctx.strokeText(
                        g[i],
                        this.centerX + this.outerRadius - l,
                        this.centerY + d
                      ))
                  : (o &&
                      this.ctx.fillText(
                        g[i],
                        this.centerX +
                          this.innerRadius +
                          (this.outerRadius - this.innerRadius) / 2 +
                          l,
                        this.centerY + d
                      ),
                    h &&
                      this.ctx.strokeText(
                        g[i],
                        this.centerX +
                          this.innerRadius +
                          (this.outerRadius - this.innerRadius) / 2 +
                          l,
                        this.centerY + d
                      )),
                this.ctx.restore();
            } else if ("vertical" == s) {
              (this.ctx.textAlign = "center"),
                (this.ctx.textBaseline =
                  "inner" == a ? "bottom" : "outer" == a ? "top" : "middle");
              m = seg.endAngle - (seg.endAngle - seg.startAngle) / 2;
              if (
                ((m += this.rotationAngle),
                this.ctx.save(),
                this.ctx.translate(this.centerX, this.centerY),
                this.ctx.rotate(this.degreeToRadious(m)),
                this.ctx.translate(-this.centerX, -this.centerY),
                "outer" == a)
              )
                p = this.centerY - this.outerRadius + l;
              else if ("inner" == a) p = this.centerY - this.innerRadius - l;
              f = e - e / 9;
              if ("outer" == a)
                for (A = 0; A < g[i].length; A++)
                  (character = g[i].charAt(A)),
                    o && this.ctx.fillText(character, this.centerX + d, p),
                    h && this.ctx.strokeText(character, this.centerX + d, p),
                    (p += f);
              else if ("inner" == a)
                for (A = g[i].length - 1; A >= 0; A--)
                  (character = g[i].charAt(A)),
                    o && this.ctx.fillText(character, this.centerX + d, p),
                    h && this.ctx.strokeText(character, this.centerX + d, p),
                    (p -= f);
              else if ("center" == a) {
                y = 0;
                g[i].length > 1 && (y = (f * (g[i].length - 1)) / 2);
                for (
                  p =
                    this.centerY -
                    this.innerRadius -
                    (this.outerRadius - this.innerRadius) / 2 -
                    y -
                    l,
                    A = 0;
                  A < g[i].length;
                  A++
                )
                  (character = g[i].charAt(A)),
                    o && this.ctx.fillText(character, this.centerX + d, p),
                    h && this.ctx.strokeText(character, this.centerX + d, p),
                    (p += f);
              }
              this.ctx.restore();
            } else if ("curved" == s) {
              k = 0;
              "inner" == a
                ? ((k = this.innerRadius + l),
                  (this.ctx.textBaseline = "bottom"),
                  (k += e * (g.length - 1)))
                : "outer" == a
                ? ((k = this.outerRadius - l), (this.ctx.textBaseline = "top"))
                : "center" == a &&
                  ((k =
                    this.innerRadius +
                    l +
                    (this.outerRadius - this.innerRadius) / 2),
                  (this.ctx.textBaseline = "middle"));
              (w = 0), (T = 0);
              for (
                g[i].length > 1
                  ? ((this.ctx.textAlign = "left"),
                    (w = (e / 10) * 4),
                    (radiusPercent = 100 / k),
                    (w *= radiusPercent),
                    (totalArc = w * g[i].length),
                    (T =
                      seg.startAngle +
                      ((seg.endAngle - seg.startAngle) / 2 - totalArc / 2)))
                  : ((T = seg.startAngle + (seg.endAngle - seg.startAngle) / 2),
                    (this.ctx.textAlign = "center")),
                  T += this.rotationAngle,
                  A = 0;
                A < g[i].length;
                A++
              )
                this.ctx.save(),
                  (character = g[i].charAt(A)),
                  this.ctx.translate(this.centerX, this.centerY),
                  this.ctx.rotate(this.degreeToRadious(T)),
                  this.ctx.translate(-this.centerX, -this.centerY),
                  h &&
                    this.ctx.strokeText(
                      character,
                      this.centerX,
                      this.centerY - k + d
                    ),
                  o &&
                    this.ctx.fillText(
                      character,
                      this.centerX,
                      this.centerY - k + d
                    ),
                  (T += w),
                  this.ctx.restore();
            }
            d += e;
          }
        }
        this.ctx.restore();
      }
  }),
  (Luckywheel.prototype.degreeToRadious = function (t) {
    return 0.017453292519943295 * t;
  }),
  (Luckywheel.prototype.getIndicatedSegment = function () {
    var t = this.getIndicatedSegmentNumber();
    return this.segments[t];
  }),
  (Luckywheel.prototype.getIndicatedSegmentNumber = function () {
    var t = 0,
      e = this.getRotationPosition(),
      i = Math.floor(this.pointerAngle - e);
    for (i < 0 && (i = 360 - Math.abs(i)), x = 1; x < this.segments.length; x++)
      if (i >= this.segments[x].startAngle && i <= this.segments[x].endAngle) {
        t = x;
        break;
      }
    return t;
  }),
  (Luckywheel.prototype.getRotationPosition = function () {
    var t = this.rotationAngle;
    if (t >= 0) {
      if (t > 360) t -= 360 * Math.floor(t / 360);
    } else {
      if (t < -360) t -= 360 * Math.ceil(t / 360);
      t = 360 + t;
    }
    return t;
  }),
  (Luckywheel.prototype.startAnimation = function () {
    if (this.animation) {
      this.computeAnimation(), (luckywheelToDrawDuringAnimation = this);
      var t = new Array(null);
      (t[this.animation.propertyName] = this.animation.propertyValue),
        (t.yoyo = this.animation.yoyo),
        (t.repeat = this.animation.repeat),
        (t.ease = this.animation.easing),
        (t.onUpdate = luckywheelAnimationLoop),
        (t.onComplete = luckywheelStopAnimation),
        (this.tween = TweenMax.to(this, this.animation.duration, t));
    }
  }),
  (Luckywheel.prototype.stopAnimation = function (t) {
    luckywheelToDrawDuringAnimation &&
      (luckywheelToDrawDuringAnimation.tween.kill(),
      luckywheelStopAnimation(t)),
      (luckywheelToDrawDuringAnimation = this);
  }),
  (Luckywheel.prototype.computeAnimation = function () {
    this.animation &&
      ("spinOngoing" == this.animation.type
        ? ((this.animation.propertyName = "rotationAngle"),
          null == this.animation.spins && (this.animation.spins = 5),
          null == this.animation.repeat && (this.animation.repeat = -1),
          null == this.animation.easing &&
            (this.animation.easing = "Linear.easeNone"),
          null == this.animation.yoyo && (this.animation.yoyo = !1),
          (this.animation.propertyValue = 360 * this.animation.spins),
          "anti-clockwise" == this.animation.direction &&
            (this.animation.propertyValue = 0 - this.animation.propertyValue))
        : "spinToStop" == this.animation.type
        ? ((this.animation.propertyName = "rotationAngle"),
          null == this.animation.spins && (this.animation.spins = 5),
          null == this.animation.repeat && (this.animation.repeat = 0),
          null == this.animation.easing &&
            (this.animation.easing = "Power3.easeOut"),
          null == this.animation.stopAngle
            ? (this.animation._stopAngle = Math.floor(359 * Math.random()))
            : (this.animation._stopAngle =
                360 - this.animation.stopAngle + this.pointerAngle),
          null == this.animation.yoyo && (this.animation.yoyo = !1),
          (this.animation.propertyValue = 360 * this.animation.spins),
          "anti-clockwise" == this.animation.direction
            ? ((this.animation.propertyValue =
                0 - this.animation.propertyValue),
              (this.animation.propertyValue -= 360 - this.animation._stopAngle))
            : (this.animation.propertyValue += this.animation._stopAngle))
        : "spinAndBack" == this.animation.type
        ? ((this.animation.propertyName = "rotationAngle"),
          null == this.animation.spins && (this.animation.spins = 5),
          null == this.animation.repeat && (this.animation.repeat = 1),
          null == this.animation.easing &&
            (this.animation.easing = "Power2.easeInOut"),
          null == this.animation.yoyo && (this.animation.yoyo = !0),
          null == this.animation.stopAngle
            ? (this.animation._stopAngle = 0)
            : (this.animation._stopAngle = 360 - this.animation.stopAngle),
          (this.animation.propertyValue = 360 * this.animation.spins),
          "anti-clockwise" == this.animation.direction
            ? ((this.animation.propertyValue =
                0 - this.animation.propertyValue),
              (this.animation.propertyValue -= 360 - this.animation._stopAngle))
            : (this.animation.propertyValue += this.animation._stopAngle))
        : this.animation.type);
  }),
  (Luckywheel.prototype.getRandomForSegment = function (t) {
    var e = 0;
    if (t)
      if (void 0 !== this.segments[t]) {
        var i = this.segments[t].startAngle,
          n = this.segments[t].endAngle - i - 2;
        n > 0
          ? (e = i + 1 + Math.floor(Math.random() * n))
          : console.log(
              "Segment size is too small to safely get random angle inside it"
            );
      } else console.log("Segment " + t + " undefined");
    else console.log("Segment number not specified");
    return e;
  });
var luckywheelToDrawDuringAnimation = null;
function luckywheelStopAnimation(canCallback) {
  if (0 != canCallback) {
    var callback = luckywheelToDrawDuringAnimation.animation.callbackFinished;
    null != callback &&
      ("function" == typeof callback
        ? callback(luckywheelToDrawDuringAnimation.getIndicatedSegment())
        : eval(callback));
  }
}
function winwheelTriggerSound() {
  0 ==
    luckywheelToDrawDuringAnimation.hasOwnProperty("_lastSoundTriggerNumber") &&
    (luckywheelToDrawDuringAnimation._lastSoundTriggerNumber = 0);
  var callbackSound = luckywheelToDrawDuringAnimation.animation.callbackSound,
    currentTriggerNumber = 0;
  (currentTriggerNumber =
    "pin" == luckywheelToDrawDuringAnimation.animation.soundTrigger
      ? luckywheelToDrawDuringAnimation.getCurrentPinNumber()
      : luckywheelToDrawDuringAnimation.getIndicatedSegmentNumber()),
    currentTriggerNumber !=
      luckywheelToDrawDuringAnimation._lastSoundTriggerNumber &&
      ("function" == typeof callbackSound
        ? callbackSound()
        : eval(callbackSound),
      (luckywheelToDrawDuringAnimation._lastSoundTriggerNumber =
        currentTriggerNumber));
}
